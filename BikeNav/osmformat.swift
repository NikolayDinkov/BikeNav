// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: osmformat.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//* Copyright (c) 2010 Scott A. Crosby. <scott@sacrosby.com>
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of
//this software and associated documentation files (the "Software"), to deal in
//the Software without restriction, including without limitation the rights to
//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//of the Software, and to permit persons to whom the Software is furnished to do
//so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct OSMPBF_HeaderBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bbox: OSMPBF_HeaderBBox {
    get {return _bbox ?? OSMPBF_HeaderBBox()}
    set {_bbox = newValue}
  }
  /// Returns true if `bbox` has been explicitly set.
  var hasBbox: Bool {return self._bbox != nil}
  /// Clears the value of `bbox`. Subsequent reads from it will return its default value.
  mutating func clearBbox() {self._bbox = nil}

  /// Additional tags to aid in parsing this dataset 
  var requiredFeatures: [String] = []

  var optionalFeatures: [String] = []

  var writingprogram: String {
    get {return _writingprogram ?? String()}
    set {_writingprogram = newValue}
  }
  /// Returns true if `writingprogram` has been explicitly set.
  var hasWritingprogram: Bool {return self._writingprogram != nil}
  /// Clears the value of `writingprogram`. Subsequent reads from it will return its default value.
  mutating func clearWritingprogram() {self._writingprogram = nil}

  /// From the bbox field.
  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  /// Replication timestamp, expressed in seconds since the epoch,
  /// otherwise the same value as in the "timestamp=..." field
  /// in the state.txt file used by Osmosis.
  var osmosisReplicationTimestamp: Int64 {
    get {return _osmosisReplicationTimestamp ?? 0}
    set {_osmosisReplicationTimestamp = newValue}
  }
  /// Returns true if `osmosisReplicationTimestamp` has been explicitly set.
  var hasOsmosisReplicationTimestamp: Bool {return self._osmosisReplicationTimestamp != nil}
  /// Clears the value of `osmosisReplicationTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearOsmosisReplicationTimestamp() {self._osmosisReplicationTimestamp = nil}

  /// Replication sequence number (sequenceNumber in state.txt).
  var osmosisReplicationSequenceNumber: Int64 {
    get {return _osmosisReplicationSequenceNumber ?? 0}
    set {_osmosisReplicationSequenceNumber = newValue}
  }
  /// Returns true if `osmosisReplicationSequenceNumber` has been explicitly set.
  var hasOsmosisReplicationSequenceNumber: Bool {return self._osmosisReplicationSequenceNumber != nil}
  /// Clears the value of `osmosisReplicationSequenceNumber`. Subsequent reads from it will return its default value.
  mutating func clearOsmosisReplicationSequenceNumber() {self._osmosisReplicationSequenceNumber = nil}

  /// Replication base URL (from Osmosis' configuration.txt file).
  var osmosisReplicationBaseURL: String {
    get {return _osmosisReplicationBaseURL ?? String()}
    set {_osmosisReplicationBaseURL = newValue}
  }
  /// Returns true if `osmosisReplicationBaseURL` has been explicitly set.
  var hasOsmosisReplicationBaseURL: Bool {return self._osmosisReplicationBaseURL != nil}
  /// Clears the value of `osmosisReplicationBaseURL`. Subsequent reads from it will return its default value.
  mutating func clearOsmosisReplicationBaseURL() {self._osmosisReplicationBaseURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bbox: OSMPBF_HeaderBBox? = nil
  fileprivate var _writingprogram: String? = nil
  fileprivate var _source: String? = nil
  fileprivate var _osmosisReplicationTimestamp: Int64? = nil
  fileprivate var _osmosisReplicationSequenceNumber: Int64? = nil
  fileprivate var _osmosisReplicationBaseURL: String? = nil
}

struct OSMPBF_HeaderBBox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var left: Int64 {
    get {return _left ?? 0}
    set {_left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return self._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {self._left = nil}

  var right: Int64 {
    get {return _right ?? 0}
    set {_right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return self._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {self._right = nil}

  var top: Int64 {
    get {return _top ?? 0}
    set {_top = newValue}
  }
  /// Returns true if `top` has been explicitly set.
  var hasTop: Bool {return self._top != nil}
  /// Clears the value of `top`. Subsequent reads from it will return its default value.
  mutating func clearTop() {self._top = nil}

  var bottom: Int64 {
    get {return _bottom ?? 0}
    set {_bottom = newValue}
  }
  /// Returns true if `bottom` has been explicitly set.
  var hasBottom: Bool {return self._bottom != nil}
  /// Clears the value of `bottom`. Subsequent reads from it will return its default value.
  mutating func clearBottom() {self._bottom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _left: Int64? = nil
  fileprivate var _right: Int64? = nil
  fileprivate var _top: Int64? = nil
  fileprivate var _bottom: Int64? = nil
}

struct OSMPBF_PrimitiveBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stringtable: OSMPBF_StringTable {
    get {return _stringtable ?? OSMPBF_StringTable()}
    set {_stringtable = newValue}
  }
  /// Returns true if `stringtable` has been explicitly set.
  var hasStringtable: Bool {return self._stringtable != nil}
  /// Clears the value of `stringtable`. Subsequent reads from it will return its default value.
  mutating func clearStringtable() {self._stringtable = nil}

  var primitivegroup: [OSMPBF_PrimitiveGroup] = []

  /// Granularity, units of nanodegrees, used to store coordinates in this block.
  var granularity: Int32 {
    get {return _granularity ?? 100}
    set {_granularity = newValue}
  }
  /// Returns true if `granularity` has been explicitly set.
  var hasGranularity: Bool {return self._granularity != nil}
  /// Clears the value of `granularity`. Subsequent reads from it will return its default value.
  mutating func clearGranularity() {self._granularity = nil}

  /// Offset value between the output coordinates and the granularity grid in units of nanodegrees.
  var latOffset: Int64 {
    get {return _latOffset ?? 0}
    set {_latOffset = newValue}
  }
  /// Returns true if `latOffset` has been explicitly set.
  var hasLatOffset: Bool {return self._latOffset != nil}
  /// Clears the value of `latOffset`. Subsequent reads from it will return its default value.
  mutating func clearLatOffset() {self._latOffset = nil}

  var lonOffset: Int64 {
    get {return _lonOffset ?? 0}
    set {_lonOffset = newValue}
  }
  /// Returns true if `lonOffset` has been explicitly set.
  var hasLonOffset: Bool {return self._lonOffset != nil}
  /// Clears the value of `lonOffset`. Subsequent reads from it will return its default value.
  mutating func clearLonOffset() {self._lonOffset = nil}

  /// Granularity of dates, normally represented in units of milliseconds since the 1970 epoch.
  var dateGranularity: Int32 {
    get {return _dateGranularity ?? 1000}
    set {_dateGranularity = newValue}
  }
  /// Returns true if `dateGranularity` has been explicitly set.
  var hasDateGranularity: Bool {return self._dateGranularity != nil}
  /// Clears the value of `dateGranularity`. Subsequent reads from it will return its default value.
  mutating func clearDateGranularity() {self._dateGranularity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stringtable: OSMPBF_StringTable? = nil
  fileprivate var _granularity: Int32? = nil
  fileprivate var _latOffset: Int64? = nil
  fileprivate var _lonOffset: Int64? = nil
  fileprivate var _dateGranularity: Int32? = nil
}

/// Group of OSMPrimitives. All primitives in a group must be the same type.
struct OSMPBF_PrimitiveGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [OSMPBF_Node] = []

  var dense: OSMPBF_DenseNodes {
    get {return _dense ?? OSMPBF_DenseNodes()}
    set {_dense = newValue}
  }
  /// Returns true if `dense` has been explicitly set.
  var hasDense: Bool {return self._dense != nil}
  /// Clears the value of `dense`. Subsequent reads from it will return its default value.
  mutating func clearDense() {self._dense = nil}

  var ways: [OSMPBF_Way] = []

  var relations: [OSMPBF_Relation] = []

  var changesets: [OSMPBF_ChangeSet] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dense: OSMPBF_DenseNodes? = nil
}

///* String table, contains the common strings in each block.
///
///Note that we reserve index '0' as a delimiter, so the entry at that
///index in the table is ALWAYS blank and unused.
struct OSMPBF_StringTable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var s: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Optional metadata that may be included into each primitive. 
struct OSMPBF_Info {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Int32 {
    get {return _version ?? -1}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var timestamp: Int64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var changeset: Int64 {
    get {return _changeset ?? 0}
    set {_changeset = newValue}
  }
  /// Returns true if `changeset` has been explicitly set.
  var hasChangeset: Bool {return self._changeset != nil}
  /// Clears the value of `changeset`. Subsequent reads from it will return its default value.
  mutating func clearChangeset() {self._changeset = nil}

  var uid: Int32 {
    get {return _uid ?? 0}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// String IDs
  var userSid: UInt32 {
    get {return _userSid ?? 0}
    set {_userSid = newValue}
  }
  /// Returns true if `userSid` has been explicitly set.
  var hasUserSid: Bool {return self._userSid != nil}
  /// Clears the value of `userSid`. Subsequent reads from it will return its default value.
  mutating func clearUserSid() {self._userSid = nil}

  /// The visible flag is used to store history information. It indicates that
  /// the current object version has been created by a delete operation on the
  /// OSM API.
  /// When a writer sets this flag, it MUST add a required_features tag with
  /// value "HistoricalInformation" to the HeaderBlock.
  /// If this flag is not available for some object it MUST be assumed to be
  /// true if the file has the required_features tag "HistoricalInformation"
  /// set.
  var visible: Bool {
    get {return _visible ?? false}
    set {_visible = newValue}
  }
  /// Returns true if `visible` has been explicitly set.
  var hasVisible: Bool {return self._visible != nil}
  /// Clears the value of `visible`. Subsequent reads from it will return its default value.
  mutating func clearVisible() {self._visible = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Int32? = nil
  fileprivate var _timestamp: Int64? = nil
  fileprivate var _changeset: Int64? = nil
  fileprivate var _uid: Int32? = nil
  fileprivate var _userSid: UInt32? = nil
  fileprivate var _visible: Bool? = nil
}

///* Optional metadata that may be included into each primitive. Special dense format used in DenseNodes. 
struct OSMPBF_DenseInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: [Int32] = []

  /// DELTA coded
  var timestamp: [Int64] = []

  /// DELTA coded
  var changeset: [Int64] = []

  /// DELTA coded
  var uid: [Int32] = []

  /// String IDs for usernames. DELTA coded
  var userSid: [Int32] = []

  /// The visible flag is used to store history information. It indicates that
  /// the current object version has been created by a delete operation on the
  /// OSM API.
  /// When a writer sets this flag, it MUST add a required_features tag with
  /// value "HistoricalInformation" to the HeaderBlock.
  /// If this flag is not available for some object it MUST be assumed to be
  /// true if the file has the required_features tag "HistoricalInformation"
  /// set.
  var visible: [Bool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This is kept for backwards compatibility but not used anywhere.
struct OSMPBF_ChangeSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int64? = nil
}

struct OSMPBF_Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// Parallel arrays.
  var keys: [UInt32] = []

  /// String IDs.
  var vals: [UInt32] = []

  /// May be omitted in omitmeta
  var info: OSMPBF_Info {
    get {return _info ?? OSMPBF_Info()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var lat: Int64 {
    get {return _lat ?? 0}
    set {_lat = newValue}
  }
  /// Returns true if `lat` has been explicitly set.
  var hasLat: Bool {return self._lat != nil}
  /// Clears the value of `lat`. Subsequent reads from it will return its default value.
  mutating func clearLat() {self._lat = nil}

  var lon: Int64 {
    get {return _lon ?? 0}
    set {_lon = newValue}
  }
  /// Returns true if `lon` has been explicitly set.
  var hasLon: Bool {return self._lon != nil}
  /// Clears the value of `lon`. Subsequent reads from it will return its default value.
  mutating func clearLon() {self._lon = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _info: OSMPBF_Info? = nil
  fileprivate var _lat: Int64? = nil
  fileprivate var _lon: Int64? = nil
}

struct OSMPBF_DenseNodes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DELTA coded
  var id: [Int64] = []

  var denseinfo: OSMPBF_DenseInfo {
    get {return _denseinfo ?? OSMPBF_DenseInfo()}
    set {_denseinfo = newValue}
  }
  /// Returns true if `denseinfo` has been explicitly set.
  var hasDenseinfo: Bool {return self._denseinfo != nil}
  /// Clears the value of `denseinfo`. Subsequent reads from it will return its default value.
  mutating func clearDenseinfo() {self._denseinfo = nil}

  /// DELTA coded
  var lat: [Int64] = []

  /// DELTA coded
  var lon: [Int64] = []

  /// Special packing of keys and vals into one array. May be empty if all nodes in this block are tagless.
  var keysVals: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _denseinfo: OSMPBF_DenseInfo? = nil
}

struct OSMPBF_Way {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// Parallel arrays.
  var keys: [UInt32] = []

  var vals: [UInt32] = []

  var info: OSMPBF_Info {
    get {return _info ?? OSMPBF_Info()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  /// DELTA coded
  var refs: [Int64] = []

  /// The following two fields are optional. They are only used in a special
  /// format where node locations are also added to the ways. This makes the
  /// files larger, but allows creating way geometries directly.
  ///
  /// If this is used, you MUST set the optional_features tag "LocationsOnWays"
  /// and the number of values in refs, lat, and lon MUST be the same.
  var lat: [Int64] = []

  /// DELTA coded, optional
  var lon: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _info: OSMPBF_Info? = nil
}

struct OSMPBF_Relation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// Parallel arrays.
  var keys: [UInt32] = []

  var vals: [UInt32] = []

  var info: OSMPBF_Info {
    get {return _info ?? OSMPBF_Info()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  /// Parallel arrays
  var rolesSid: [Int32] = []

  /// DELTA encoded
  var memids: [Int64] = []

  var types: [OSMPBF_Relation.MemberType] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MemberType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case node // = 0
    case way // = 1
    case relation // = 2

    init() {
      self = .node
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .node
      case 1: self = .way
      case 2: self = .relation
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .node: return 0
      case .way: return 1
      case .relation: return 2
      }
    }

  }

  init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _info: OSMPBF_Info? = nil
}

#if swift(>=4.2)

extension OSMPBF_Relation.MemberType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "OSMPBF"

extension OSMPBF_HeaderBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeaderBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bbox"),
    4: .standard(proto: "required_features"),
    5: .standard(proto: "optional_features"),
    16: .same(proto: "writingprogram"),
    17: .same(proto: "source"),
    32: .standard(proto: "osmosis_replication_timestamp"),
    33: .standard(proto: "osmosis_replication_sequence_number"),
    34: .standard(proto: "osmosis_replication_base_url"),
  ]

  public var isInitialized: Bool {
    if let v = self._bbox, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bbox) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.requiredFeatures) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.optionalFeatures) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self._writingprogram) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 32: try { try decoder.decodeSingularInt64Field(value: &self._osmosisReplicationTimestamp) }()
      case 33: try { try decoder.decodeSingularInt64Field(value: &self._osmosisReplicationSequenceNumber) }()
      case 34: try { try decoder.decodeSingularStringField(value: &self._osmosisReplicationBaseURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bbox {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.requiredFeatures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requiredFeatures, fieldNumber: 4)
    }
    if !self.optionalFeatures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.optionalFeatures, fieldNumber: 5)
    }
    try { if let v = self._writingprogram {
      try visitor.visitSingularStringField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 17)
    } }()
    try { if let v = self._osmosisReplicationTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 32)
    } }()
    try { if let v = self._osmosisReplicationSequenceNumber {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 33)
    } }()
    try { if let v = self._osmosisReplicationBaseURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 34)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_HeaderBlock, rhs: OSMPBF_HeaderBlock) -> Bool {
    if lhs._bbox != rhs._bbox {return false}
    if lhs.requiredFeatures != rhs.requiredFeatures {return false}
    if lhs.optionalFeatures != rhs.optionalFeatures {return false}
    if lhs._writingprogram != rhs._writingprogram {return false}
    if lhs._source != rhs._source {return false}
    if lhs._osmosisReplicationTimestamp != rhs._osmosisReplicationTimestamp {return false}
    if lhs._osmosisReplicationSequenceNumber != rhs._osmosisReplicationSequenceNumber {return false}
    if lhs._osmosisReplicationBaseURL != rhs._osmosisReplicationBaseURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_HeaderBBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeaderBBox"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
    2: .same(proto: "right"),
    3: .same(proto: "top"),
    4: .same(proto: "bottom"),
  ]

  public var isInitialized: Bool {
    if self._left == nil {return false}
    if self._right == nil {return false}
    if self._top == nil {return false}
    if self._bottom == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt64Field(value: &self._left) }()
      case 2: try { try decoder.decodeSingularSInt64Field(value: &self._right) }()
      case 3: try { try decoder.decodeSingularSInt64Field(value: &self._top) }()
      case 4: try { try decoder.decodeSingularSInt64Field(value: &self._bottom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._left {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._right {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._top {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bottom {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_HeaderBBox, rhs: OSMPBF_HeaderBBox) -> Bool {
    if lhs._left != rhs._left {return false}
    if lhs._right != rhs._right {return false}
    if lhs._top != rhs._top {return false}
    if lhs._bottom != rhs._bottom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_PrimitiveBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrimitiveBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stringtable"),
    2: .same(proto: "primitivegroup"),
    17: .same(proto: "granularity"),
    19: .standard(proto: "lat_offset"),
    20: .standard(proto: "lon_offset"),
    18: .standard(proto: "date_granularity"),
  ]

  public var isInitialized: Bool {
    if self._stringtable == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.primitivegroup) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stringtable) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.primitivegroup) }()
      case 17: try { try decoder.decodeSingularInt32Field(value: &self._granularity) }()
      case 18: try { try decoder.decodeSingularInt32Field(value: &self._dateGranularity) }()
      case 19: try { try decoder.decodeSingularInt64Field(value: &self._latOffset) }()
      case 20: try { try decoder.decodeSingularInt64Field(value: &self._lonOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stringtable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.primitivegroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.primitivegroup, fieldNumber: 2)
    }
    try { if let v = self._granularity {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 17)
    } }()
    try { if let v = self._dateGranularity {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 18)
    } }()
    try { if let v = self._latOffset {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 19)
    } }()
    try { if let v = self._lonOffset {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 20)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_PrimitiveBlock, rhs: OSMPBF_PrimitiveBlock) -> Bool {
    if lhs._stringtable != rhs._stringtable {return false}
    if lhs.primitivegroup != rhs.primitivegroup {return false}
    if lhs._granularity != rhs._granularity {return false}
    if lhs._latOffset != rhs._latOffset {return false}
    if lhs._lonOffset != rhs._lonOffset {return false}
    if lhs._dateGranularity != rhs._dateGranularity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_PrimitiveGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrimitiveGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "dense"),
    3: .same(proto: "ways"),
    4: .same(proto: "relations"),
    5: .same(proto: "changesets"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.nodes) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.ways) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.relations) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.changesets) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dense) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.ways) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.changesets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._dense {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ways.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ways, fieldNumber: 3)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 4)
    }
    if !self.changesets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changesets, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_PrimitiveGroup, rhs: OSMPBF_PrimitiveGroup) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._dense != rhs._dense {return false}
    if lhs.ways != rhs.ways {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.changesets != rhs.changesets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_StringTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringTable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.s) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.s.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.s, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_StringTable, rhs: OSMPBF_StringTable) -> Bool {
    if lhs.s != rhs.s {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_Info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Info"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "changeset"),
    4: .same(proto: "uid"),
    5: .standard(proto: "user_sid"),
    6: .same(proto: "visible"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._changeset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._uid) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._userSid) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._visible) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._changeset {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._uid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._userSid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._visible {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_Info, rhs: OSMPBF_Info) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._changeset != rhs._changeset {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._userSid != rhs._userSid {return false}
    if lhs._visible != rhs._visible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_DenseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenseInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "changeset"),
    4: .same(proto: "uid"),
    5: .standard(proto: "user_sid"),
    6: .same(proto: "visible"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeRepeatedSInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeRepeatedSInt64Field(value: &self.changeset) }()
      case 4: try { try decoder.decodeRepeatedSInt32Field(value: &self.uid) }()
      case 5: try { try decoder.decodeRepeatedSInt32Field(value: &self.userSid) }()
      case 6: try { try decoder.decodeRepeatedBoolField(value: &self.visible) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitPackedInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if !self.changeset.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.changeset, fieldNumber: 3)
    }
    if !self.uid.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.uid, fieldNumber: 4)
    }
    if !self.userSid.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.userSid, fieldNumber: 5)
    }
    if !self.visible.isEmpty {
      try visitor.visitPackedBoolField(value: self.visible, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_DenseInfo, rhs: OSMPBF_DenseInfo) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.changeset != rhs.changeset {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.userSid != rhs.userSid {return false}
    if lhs.visible != rhs.visible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_ChangeSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_ChangeSet, rhs: OSMPBF_ChangeSet) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Node"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "keys"),
    3: .same(proto: "vals"),
    4: .same(proto: "info"),
    8: .same(proto: "lat"),
    9: .same(proto: "lon"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._lat == nil {return false}
    if self._lon == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.keys) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.vals) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 8: try { try decoder.decodeSingularSInt64Field(value: &self._lat) }()
      case 9: try { try decoder.decodeSingularSInt64Field(value: &self._lon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.keys, fieldNumber: 2)
    }
    if !self.vals.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.vals, fieldNumber: 3)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._lat {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._lon {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_Node, rhs: OSMPBF_Node) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.vals != rhs.vals {return false}
    if lhs._info != rhs._info {return false}
    if lhs._lat != rhs._lat {return false}
    if lhs._lon != rhs._lon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_DenseNodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenseNodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    5: .same(proto: "denseinfo"),
    8: .same(proto: "lat"),
    9: .same(proto: "lon"),
    10: .standard(proto: "keys_vals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSInt64Field(value: &self.id) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._denseinfo) }()
      case 8: try { try decoder.decodeRepeatedSInt64Field(value: &self.lat) }()
      case 9: try { try decoder.decodeRepeatedSInt64Field(value: &self.lon) }()
      case 10: try { try decoder.decodeRepeatedInt32Field(value: &self.keysVals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._denseinfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.lat.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.lat, fieldNumber: 8)
    }
    if !self.lon.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.lon, fieldNumber: 9)
    }
    if !self.keysVals.isEmpty {
      try visitor.visitPackedInt32Field(value: self.keysVals, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_DenseNodes, rhs: OSMPBF_DenseNodes) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._denseinfo != rhs._denseinfo {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.keysVals != rhs.keysVals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_Way: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Way"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "keys"),
    3: .same(proto: "vals"),
    4: .same(proto: "info"),
    8: .same(proto: "refs"),
    9: .same(proto: "lat"),
    10: .same(proto: "lon"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.keys) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.vals) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 8: try { try decoder.decodeRepeatedSInt64Field(value: &self.refs) }()
      case 9: try { try decoder.decodeRepeatedSInt64Field(value: &self.lat) }()
      case 10: try { try decoder.decodeRepeatedSInt64Field(value: &self.lon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.keys, fieldNumber: 2)
    }
    if !self.vals.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.vals, fieldNumber: 3)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.refs.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.refs, fieldNumber: 8)
    }
    if !self.lat.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.lat, fieldNumber: 9)
    }
    if !self.lon.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.lon, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_Way, rhs: OSMPBF_Way) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.vals != rhs.vals {return false}
    if lhs._info != rhs._info {return false}
    if lhs.refs != rhs.refs {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Relation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "keys"),
    3: .same(proto: "vals"),
    4: .same(proto: "info"),
    8: .standard(proto: "roles_sid"),
    9: .same(proto: "memids"),
    10: .same(proto: "types"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.keys) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.vals) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 8: try { try decoder.decodeRepeatedInt32Field(value: &self.rolesSid) }()
      case 9: try { try decoder.decodeRepeatedSInt64Field(value: &self.memids) }()
      case 10: try { try decoder.decodeRepeatedEnumField(value: &self.types) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.keys, fieldNumber: 2)
    }
    if !self.vals.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.vals, fieldNumber: 3)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.rolesSid.isEmpty {
      try visitor.visitPackedInt32Field(value: self.rolesSid, fieldNumber: 8)
    }
    if !self.memids.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.memids, fieldNumber: 9)
    }
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OSMPBF_Relation, rhs: OSMPBF_Relation) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.vals != rhs.vals {return false}
    if lhs._info != rhs._info {return false}
    if lhs.rolesSid != rhs.rolesSid {return false}
    if lhs.memids != rhs.memids {return false}
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMPBF_Relation.MemberType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NODE"),
    1: .same(proto: "WAY"),
    2: .same(proto: "RELATION"),
  ]
}
